const mongoose = require('mongoose');
const { Schema } = mongoose;

const { encryptData, compareEncryptedWithClearData } = require('../utils/utilities');
require('mongoose-type-email');

const MAX_PARAGRAPH_LENGTH = 500;
const MAX_NAME_LENGTH = 50;

const ratingSchema = {
  totalOfAllRatings: { type: Number, default: 0 },
  numberOfTimesBeenRated: { type: Number, default: 0 },
  globalRating: { type: Number, default: 0 },
  fulfilledBids: {
    type: [{ type: Schema.Types.ObjectId, ref: 'BidModel' }],
  },
  canceledBids: {
    type: [{ type: Schema.Types.ObjectId, ref: 'BidModel' }],
  },
  fulfilledJobs: {
    type: [{ type: Schema.Types.ObjectId, ref: 'JobModel' }],
  },
  canceledJobs: {
    type: [{ type: Schema.Types.ObjectId, ref: 'JobModel' }],
  },
  latestComment: { type: String, trim: true },
};

const UserSchema = new Schema(
  {
    _postedJobsRef: {
      type: [{ type: Schema.Types.ObjectId, ref: 'JobModel' }],
    }, //list of all jobs you have posted
    _postedBidsRef: {
      type: [{ type: Schema.Types.ObjectId, ref: 'BidModel' }],
    }, // list of all bids you made
    _asBidderReviewsRef: [{ type: Schema.Types.ObjectId, ref: 'ReviewModel' }],
    _asProposerReviewsRef: [{ type: Schema.Types.ObjectId, ref: 'ReviewModel' }],
    rating: ratingSchema,
    userId: {
      type: String,
      lowercase: true,
      trim: true,
      index: true,
      unique: true,
      required: true,
    },
    email: {
      emailAddress: {
        type: mongoose.SchemaTypes.Email,
        allowBlank: true,
        lowercase: true,
        trim: true,
        index: true,
      },
      isVerified: {
        type: Boolean,
        default: false,
      },
    },
    password: {
      type: String,
      minlength: 6,
      required: false,
    },
    phone: {
      phoneNumber: {
        type: String,
        trim: true,
      },
      isVerified: {
        type: Boolean,
        default: false,
      },
    },
    verification: {
      email: {
        type: Map,
        of: String,
      },
      phone: {
        type: Map,
        of: String,
      },
    },
    displayName: {
      type: String,
      trim: true,
      maxlength: MAX_NAME_LENGTH,
    },
    profileImage: {
      url: { type: String, default: 'https://static.thenounproject.com/png/630729-200.png' },
      public_id: { type: String },
    },
    addressText: { type: String, maxlength: MAX_PARAGRAPH_LENGTH },
    // skills: [String], // list of strings representing their skills
    personalParagraph: { type: String, maxlength: MAX_PARAGRAPH_LENGTH }, // a blob about who they are
    // paymentRefs: [String], // ID to fetch their payments through our system to generate an invoice
    membershipStatus: {
      type: String,
      enum: [
        'NEW_MEMBER',
        'VERIFIED_MEMBER',
        'BRONZE_MEMBER',
        'SILVER_MEMBER',
        'GOLDEN_MEMBER',
        'PLATINUM_MEMBER',
      ],
      default: 'NEW_MEMBER',
    },
    pushSubscription: { type: String },
    userRole: {
      type: String,
      enum: ['ADMIN', 'REGULAR'],
      default: 'REGULAR',
    },
    agreedToServiceTerms: { type: Boolean, required: true, default: false },
    settings: { type: Object },
    extras: { type: Object },
    stripeConnect: {
      accId: { type: String },
      isVerified: { type: Boolean, default: false },
      last4BankAcc: { type: String },
    },
    canBid: { type: Boolean, default: true },
    canPost: { type: Boolean, default: true },
  },
  { timestamps: true } // createdAt and updatedAt auto  generated by mongoose
);

UserSchema.pre('save', async function(next) {
  if (this.password) {
    this.password = await encryptData(this.password);
    if (this.password.errorMsg) {
      // error case
      next(this.password);
    }
  }
  next();
});
UserSchema.methods.checkUserPassword = async function(candidatePassword) {
  const isTheRightPassword = await compareEncryptedWithClearData(candidatePassword, this.password);
  return isTheRightPassword;
};

UserSchema.pre('update', async function(next) {
  // this probably does not work what so ever
  if (this.password) {
    this.password = await encryptData(this.password);
    if (this.password.errorMsg) {
      // error case
      next(this.password);
    }
  }
  next();
});
mongoose.model('UserModel', UserSchema);
