const mongoose = require('mongoose');
require('mongoose-geojson-schema');
const mongooseLeanVirtuals = require('mongoose-lean-virtuals');
const moment = require('moment');

const { Schema } = mongoose;

const StatsSchema = {
  minbid: Number, // in the future make it enum [ 'address field' , fone number ... date ..etc]
  avg: Number,
  max: Number,
  recommended: String, //reference to the ideal bid which is =  $bid amount /bidder's rating
};

const MAX_ADDRESS_LENGTH = 300;

const JobSchema = new Schema(
  {
    _ownerRef: { type: Schema.Types.ObjectId, ref: 'UserModel', required: true },
    _bidsListRef: [{ type: Schema.Types.ObjectId, ref: 'BidModel' }],
    _awardedBidRef: {
      type: Schema.Types.ObjectId,
      ref: 'BidModel',
    },
    processedPayment: {
      chargeId: { type: String },
      amount: { type: Number },
      paymentSourceId: { type: String },
      bidderPayout: { type: Number },
      platformCharge: { type: Number },
      proposerPaid: { type: Number },
      bidderStripeAcc: { type: String },
      refund: {
        amount: { type: Number },
        charge: { type: String },
        id: { type: String },
        status: { type: String },
      },
    },
    _reviewRef: { type: Schema.Types.ObjectId, ref: 'ReviewModel' },
    state: {
      type: String,
      default: 'OPEN',
      index: true,
      enum: [
        'OPEN',
        'AWARDED', //
        'DISPUTED', // disputed job
        'AWARDED_CANCELED_BY_BIDDER',
        'AWARDED_CANCELED_BY_REQUESTER',
        'CANCELED_OPEN', // Requester cancels a job before awarding
        'TO_BE_DELETED_SOON', // past due and no taskers assigned delete in 48h
        'DONE', //when Tasker confirms we set it to Payout , later a cron job will pay the account
        'PAYMENT_RELEASED',
        'ARCHIVE', //For historical record
      ],
    },
    dispute: {
      taskerDispute: {
        reason: { type: String },
        details: { type: String },
        default: {},
      },
      proposerDispute: {
        reason: { type: String },
        details: { type: String },
        default: {},
      },
    },
    jobCompletion: {
      proposerConfirmed: { type: Boolean, default: false },
      bidderConfirmed: { type: Boolean, default: false },
      bidderDisputed: { type: Boolean, default: false },
      proposerDisputed: { type: Boolean, default: false },
    },
    reschedule: {
      newTime: { type: Date },
      byWhom: { type: String, enum: ['owner', 'bidder'] },
      status: { type: String, enum: ['denied', 'accepted'] },
    },
    // when a tasker cancels on this job hide it from them to avoid future bids by the asshole who canceled
    hideFrom: [{ type: Schema.Types.ObjectId, ref: 'UserModel' }], //array of people who saw this/booed no longer wish to see it ..etc
    viewedBy: [{ type: Schema.Types.ObjectId, ref: 'UserModel' }],
    booedBy: [{ type: Schema.Types.ObjectId, ref: 'UserModel' }],
    detailedDescription: { type: String, trim: true },
    stats: StatsSchema,
    location: { type: mongoose.Schema.Types.Point, index: '2dsphere' },
    addressText: { type: String, trim: true, max: MAX_ADDRESS_LENGTH },
    startingDateAndTime: { type: Date, required: true, index: true },
    templateId: { type: String, trim: true },
    reported: { type: Number },
    payoutDetails: {
      id: { type: String },
      status: { type: String },
    },
    // jobImages: [
    //   {
    //     url: { type: String },
    //     public_id: { type: String },
    //   },
    // ],
    extras: { type: Object },
  },
  { timestamps: true } // createdAt and updatedAt auto generated by mongoose
);

// JobSchema.pre('save', async function(next) {
//   if (this.startingDateAndTime && this.startingDateAndTime) {
//     this.startingDateAndTime = moment(
//       moment(this.startingDateAndTime).set({ hour: 0, minute: 0, second: 0, millisecond: 0 })
//     ).toISOString();
//   }
//   next();
// });

JobSchema.virtual('displayTitle').get(function() {
  const templateIdToDisplayName = {
    'bdbjob-house-cleaning': 'House Cleaning',
    'bdbjob-car-detailing': 'Car Detailing',
  };
  return templateIdToDisplayName[this.templateId];
});

JobSchema.virtual('isPastDue').get(function() {
  const now = moment()
    .tz('America/Toronto')
    .toISOString();
  const jobStartDate = this.startingDateAndTime;

  // normalize the start date to the same timezone to comapre
  const normalizedStartDate = moment(jobStartDate)
    .tz('America/Toronto')
    .toISOString();
  const isJobScheduledTimePastDue = moment(normalizedStartDate).isSameOrBefore(now);

  return isJobScheduledTimePastDue;
});

JobSchema.virtual('isHappeningToday').get(function() {
  const startOfDay = moment()
    .tz('America/Toronto')
    .startOf('day')
    .toISOString();
  const endOfDay = moment()
    .tz('America/Toronto')
    .endOf('day')
    .toISOString();

  const jobStartDate = this.startingDateAndTime;
  // normalize the start date to the same timezone to comapre
  const normalizedStartDate = moment(jobStartDate)
    .tz('America/Toronto')
    .toISOString();

  const isJobHappeningAfterToday = moment(normalizedStartDate).isSameOrAfter(startOfDay);
  const isJobHappeningBeforeTomorrow = moment(normalizedStartDate).isSameOrBefore(endOfDay);
  return isJobHappeningAfterToday && isJobHappeningBeforeTomorrow;
});

JobSchema.virtual('isHappeningSoon').get(function() {
  const theNext24Hours = moment()
    .tz('America/Toronto')
    .add(1, 'day')
    .startOf('day');

  const jobStartDate = this.startingDateAndTime;
  // normalize the start date to the same timezone to comapre
  const normalizedStartDate = moment(jobStartDate).tz('America/Toronto');

  var duration = moment.duration(theNext24Hours.diff(normalizedStartDate));
  var hours = duration.asHours();

  const isNotPastDue = moment(theNext24Hours.toISOString()).isAfter(
    normalizedStartDate.toISOString()
  );

  // if job is about to expire in 48 hours
  return hours <= 48 && isNotPastDue;
});

JobSchema.virtual('displayStatus').get(function() {
  const stateToDisplayName = {
    OPEN: 'Waiting On Taskers Bids',
    AWARDED: 'Tasker is Assigned',
    DISPUTED: 'Dispute',
    AWARDED_CANCELED_BY_BIDDER: 'Tasker Cancelled the Agreement',
    AWARDED_CANCELED_BY_REQUESTER: 'Requester Cancelled the Agreement',
    CANCELED_OPEN: 'Canceled Request',
    DONE: 'Completed',
    PAYMENT_RELEASED: 'Payment sent to Tasker',
    TO_BE_DELETED_SOON: 'Will be deleted soon',
    ARCHIVE: 'Archived',
  };
  return stateToDisplayName[this.state];
});

JobSchema.plugin(mongooseLeanVirtuals);

//no need for index on these . avoid performance slowness
mongoose.model('JobModel', JobSchema);
