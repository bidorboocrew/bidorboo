const mongoose = require('mongoose');
require('mongoose-geojson-schema');
const mongooseLeanVirtuals = require('mongoose-lean-virtuals');
const moment = require('moment');

const { Schema } = mongoose;

const MAX_ADDRESS_LENGTH = 300;

const JobSchema = new Schema(
  {
    _ownerRef: { type: Schema.Types.ObjectId, ref: 'UserModel', required: true },
    _bidsListRef: [{ type: Schema.Types.ObjectId, ref: 'BidModel' }],
    _awardedBidRef: {
      type: Schema.Types.ObjectId,
      ref: 'BidModel',
    },
    _reviewRef: { type: Schema.Types.ObjectId, ref: 'ReviewModel' },
    processedPayment: {
      chargeId: { type: String },
      amount: { type: Number, min: 0, max: 10000 },
      paymentSourceId: { type: String },
      bidderPayout: { type: Number, min: 0, max: 10000 },
      platformCharge: { type: Number, min: 0, max: 10000 },
      proposerPaid: { type: Number, min: 0, max: 10000 },
      bidderStripeAcc: { type: String },
      refund: {
        amount: { type: Number, min: 0, max: 10000 },
        charge: { type: String },
        id: { type: String },
        status: { type: String },
      },
    },
    state: {
      type: String,
      default: 'OPEN',
      index: true,
      enum: [
        'OPEN',
        'AWARDED', //
        'DISPUTED', // disputed job
        'AWARDED_JOB_CANCELED_BY_BIDDER',
        'AWARDED_JOB_CANCELED_BY_REQUESTER',
        'CANCELED_OPEN', // Requester cancels a job before awarding
        'DONE', //when Tasker confirms we set it to Payout , later a cron job will pay the account
        'PAYMENT_RELEASED',
        'PAYMENT_TO_BANK_FAILED',
        'ARCHIVE', //For historical record
      ],
    },
    dispute: {
      taskerDispute: {
        reason: { type: String },
        details: { type: String },
      },
      proposerDispute: {
        reason: { type: String },
        details: { type: String },
      },
    },
    jobCompletion: {
      proposerConfirmed: { type: Boolean, default: false },
      bidderConfirmed: { type: Boolean, default: false },
      bidderDisputed: { type: Boolean, default: false },
      proposerDisputed: { type: Boolean, default: false },
    },

    // when a tasker cancels on this job hide it from them to avoid future bids by the asshole who canceled
    hideFrom: [{ type: Schema.Types.ObjectId, ref: 'UserModel' }], //array of people who saw this/booed no longer wish to see it ..etc
    viewedBy: [{ type: Schema.Types.ObjectId, ref: 'UserModel' }],
    detailedDescription: { type: String, trim: true },
    location: { type: mongoose.Schema.Types.Point, index: '2dsphere' },
    addressText: { type: String, trim: true, max: MAX_ADDRESS_LENGTH },
    startingDateAndTime: { type: Date, required: true, index: true },
    templateId: { type: String, trim: true },
    reported: { type: Number },
    payoutDetails: {
      id: { type: String },
      status: { type: String },
    },
    extras: { type: Object },
    // jobImages: [
    //   {
    //     url: { type: String },
    //     public_id: { type: String },
    //   },
    // ],
    // reschedule: {
    //   newTime: { type: Date },
    //   byWhom: { type: String, enum: ['owner', 'bidder'] },
    //   status: { type: String, enum: ['denied', 'accepted'] },
    // },
  },
  { timestamps: true } // createdAt and updatedAt auto generated by mongoose
);

JobSchema.virtual('displayTitle').get(function() {
  const templateIdToDisplayName = {
    'bdbjob-house-cleaning': 'House Cleaning',
    'bdbjob-car-detailing': 'Car Detailing',
  };
  return templateIdToDisplayName[this.templateId];
});

JobSchema.virtual('isPastDue').get(function() {
  const now = moment()
    .tz('America/Toronto')
    .toISOString();
  const jobStartDate = this.startingDateAndTime;

  // normalize the start date to the same timezone to comapre
  const normalizedStartDate = moment(jobStartDate)
    .tz('America/Toronto')
    .toISOString();
  const isJobScheduledTimePastDue = moment(normalizedStartDate).isSameOrBefore(now);

  return isJobScheduledTimePastDue;
});

JobSchema.virtual('isHappeningToday').get(function() {
  const startOfDay = moment()
    .tz('America/Toronto')
    .startOf('day')
    .toISOString();
  const endOfDay = moment()
    .tz('America/Toronto')
    .endOf('day')
    .toISOString();

  const jobStartDate = this.startingDateAndTime;
  // normalize the start date to the same timezone to comapre
  const normalizedStartDate = moment(jobStartDate)
    .tz('America/Toronto')
    .toISOString();

  const isJobHappeningAfterToday = moment(normalizedStartDate).isSameOrAfter(startOfDay);
  const isJobHappeningBeforeTomorrow = moment(normalizedStartDate).isSameOrBefore(endOfDay);
  return isJobHappeningAfterToday && isJobHappeningBeforeTomorrow;
});

JobSchema.virtual('isHappeningSoon').get(function() {
  const theNext24Hours = moment()
    .tz('America/Toronto')
    .add(1, 'day')
    .startOf('day');

  const jobStartDate = this.startingDateAndTime;
  // normalize the start date to the same timezone to comapre
  const normalizedStartDate = moment(jobStartDate).tz('America/Toronto');

  var duration = moment.duration(theNext24Hours.diff(normalizedStartDate));
  var hours = duration.asHours();

  const isNotPastDue = moment(theNext24Hours.toISOString()).isAfter(
    normalizedStartDate.toISOString()
  );

  // if job is about to expire in 48 hours
  return hours <= 48 && isNotPastDue;
});

JobSchema.virtual('displayStatus').get(function() {
  const stateToDisplayName = {
    OPEN: 'Waiting On Taskers Bids',
    AWARDED: 'Tasker is Assigned',
    DISPUTED: 'Dispute',
    AWARDED_JOB_CANCELED_BY_BIDDER: 'Tasker Cancelled the Agreement',
    AWARDED_JOB_CANCELED_BY_REQUESTER: 'Requester Cancelled the Agreement',
    CANCELED_OPEN: 'Canceled Request',
    DONE: 'Completed',
    PAYMENT_RELEASED: 'Payment sent to Tasker',
    PAYMENT_TO_BANK_FAILED: "Couldn't release funds to your bank",
    ARCHIVE: 'Archived',
  };
  return stateToDisplayName[this.state];
});

JobSchema.plugin(mongooseLeanVirtuals);

//no need for index on these . avoid performance slowness
mongoose.model('JobModel', JobSchema);
