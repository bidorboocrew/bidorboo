const mongoose = require('mongoose');
require('mongoose-geojson-schema');
const mongooseLeanVirtuals = require('mongoose-lean-virtuals');
const moment = require('moment-timezone');

const { detroyExistingImg } = require('../utils/utilities');

const { Schema } = mongoose;

const MAX_ADDRESS_LENGTH = 300;
const MIN_ADDRESS_LENGTH = 5;

const MIN_BID_AMOUNT = 10 * 100;
const MAX_BID_AMOUNT = 5000 * 100;
const MAX_IMAGE_COUNT = 3;

const JobSchema = new Schema(
  {
    _ownerRef: { type: Schema.Types.ObjectId, ref: 'UserModel', required: true },
    _bidsListRef: [{ type: Schema.Types.ObjectId, ref: 'BidModel' }],
    _awardedBidRef: {
      type: Schema.Types.ObjectId,
      ref: 'BidModel',
    },
    _reviewRef: { type: Schema.Types.ObjectId, ref: 'ReviewModel' },
    processedPayment: {
      paymentIntentId: { type: String },
      paymentMethodId: { type: String },
      destinationStripeAcc: { type: String },
      chargeId: { type: String },
      applicationFeeAmount: { type: Number, min: MIN_BID_AMOUNT * 100, max: MAX_BID_AMOUNT * 100 },
      amount: { type: Number, min: MIN_BID_AMOUNT * 100, max: MAX_BID_AMOUNT * 100 },
      refund: {
        amount: { type: Number, min: MIN_BID_AMOUNT, max: MAX_BID_AMOUNT },
        paymentIntentId: { type: String },
        id: { type: String },
        status: { type: String },
      },
    },
    state: {
      type: String,
      default: 'OPEN',
      index: true,
      enum: [
        'OPEN',
        'AWARDED', //
        'DISPUTED', // disputed job
        'AWARDED_JOB_CANCELED_BY_BIDDER',
        'AWARDED_JOB_CANCELED_BY_REQUESTER',
        'CANCELED_OPEN', // Requester cancels a job before awarding
        'DONE', //when Tasker confirms we set it to Payout , later a cron job will pay the account
        'PAYMENT_RELEASED',
        'PAYMENT_TO_BANK_FAILED',
        'ARCHIVE', //For historical record
      ],
    },
    dispute: {
      taskerDispute: {
        reason: { type: String },
        details: { type: String },
      },
      proposerDispute: {
        reason: { type: String },
        details: { type: String },
      },
    },
    // why do we have this
    jobCompletion: {
      proposerConfirmed: { type: Boolean, default: false },
      bidderConfirmed: { type: Boolean, default: false },
      bidderDisputed: { type: Boolean, default: false },
      proposerDisputed: { type: Boolean, default: false },
    },
    // when a tasker cancels on this job hide it from them to avoid future bids by the asshole who canceled
    hideFrom: [{ type: Schema.Types.ObjectId, ref: 'UserModel' }], //array of people who saw this/booed no longer wish to see it ..etc
    viewedBy: [{ type: Schema.Types.ObjectId, ref: 'UserModel' }],

    detailedDescription: { type: String, trim: true, required: true },
    location: { type: mongoose.Schema.Types.Point, index: '2dsphere', required: true },
    addressText: {
      type: String,
      trim: true,
      maxlength: [
        MAX_ADDRESS_LENGTH,
        'Address text can not be longer than ' + MAX_ADDRESS_LENGTH + ' charachters',
      ],
      minlength: [
        MIN_ADDRESS_LENGTH,
        'Address text can not be longer than ' + MIN_ADDRESS_LENGTH + ' charachters',
      ],
      required: [true, 'Address text is required'],
    },
    startingDateAndTime: {
      type: Date,
      required: true,
      index: true,
      required: true,
      validate: {
        validator: (val) => {
          const now = moment()
            .tz('America/Toronto')
            .toISOString();
          const normalizedStartDate = moment(val)
            .tz('America/Toronto')
            .toISOString();
          const isJobScheduledTimePastDue = moment(normalizedStartDate).isSameOrBefore(now);
          return !isJobScheduledTimePastDue;
        },
        message: 'You can attach a maximum of ' + MAX_IMAGE_COUNT + 'images',
      },
    },
    templateId: {
      type: String,
      trim: true,
      required: true,
      enum: ['bdbCarDetailing', 'bdbHouseCleaning', 'bdbPetSittingWalking'],
    },
    reported: { type: Number },
    payoutDetails: {
      id: { type: String },
      status: { type: String },
    },
    taskImages: {
      type: [
        {
          url: { type: String },
          public_id: { type: String },
        },
      ],
      validate: {
        validator: (val) => val && val.length <= MAX_IMAGE_COUNT,
        message: 'You can attach a maximum of ' + MAX_IMAGE_COUNT + 'images',
      },
    },
    extras: { type: Object },
  },
  { timestamps: true } // createdAt and updatedAt auto generated by mongoose
);

JobSchema.virtual('displayTitle').get(function() {
  const templateIdToDisplayName = {
    bdbHouseCleaning: 'House Cleaning',
    bdbCarDetailing: 'Car Detailing',
    bdbPetSittingWalking: 'Pet Sitting/Walking',
  };
  return templateIdToDisplayName[this.templateId];
});

JobSchema.virtual('isPastDue').get(function() {
  const now = moment()
    .tz('America/Toronto')
    .toISOString();
  const jobStartDate = this.startingDateAndTime;

  // normalize the start date to the same timezone to comapre
  const normalizedStartDate = moment(jobStartDate)
    .tz('America/Toronto')
    .toISOString();
  const isJobScheduledTimePastDue = moment(normalizedStartDate).isSameOrBefore(now);

  return isJobScheduledTimePastDue;
});

JobSchema.virtual('isHappeningToday').get(function() {
  const startOfDay = moment()
    .tz('America/Toronto')
    .startOf('day')
    .toISOString();
  const endOfDay = moment()
    .tz('America/Toronto')
    .endOf('day')
    .toISOString();

  const jobStartDate = this.startingDateAndTime;
  // normalize the start date to the same timezone to comapre
  const normalizedStartDate = moment(jobStartDate)
    .tz('America/Toronto')
    .toISOString();

  const isJobHappeningAfterToday = moment(normalizedStartDate).isSameOrAfter(startOfDay);
  const isJobHappeningBeforeTomorrow = moment(normalizedStartDate).isSameOrBefore(endOfDay);
  return isJobHappeningAfterToday && isJobHappeningBeforeTomorrow;
});

JobSchema.virtual('isHappeningSoon').get(function() {
  const theNext24Hours = moment()
    .tz('America/Toronto')
    .add(1, 'day')
    .startOf('day');

  const jobStartDate = this.startingDateAndTime;
  // normalize the start date to the same timezone to comapre
  const normalizedStartDate = moment(jobStartDate).tz('America/Toronto');

  var duration = moment.duration(theNext24Hours.diff(normalizedStartDate));
  var hours = duration.asHours();

  const isNotPastDue = moment(theNext24Hours.toISOString()).isAfter(
    normalizedStartDate.toISOString()
  );

  // if job is about to expire in 48 hours
  return hours <= 48 && isNotPastDue;
});

JobSchema.virtual('displayStatus').get(function() {
  const stateToDisplayName = {
    OPEN: 'Waiting On Taskers Bids',
    AWARDED: 'Tasker is Assigned',
    DISPUTED: 'Dispute',
    AWARDED_JOB_CANCELED_BY_BIDDER: 'Tasker Cancelled the Agreement',
    AWARDED_JOB_CANCELED_BY_REQUESTER: 'Requester Cancelled the Agreement',
    CANCELED_OPEN: 'Canceled Request',
    DONE: 'Completed',
    PAYMENT_RELEASED: 'Payment sent to Tasker',
    PAYMENT_TO_BANK_FAILED: "Couldn't release funds to your bank",
    ARCHIVE: 'Archived',
  };
  return stateToDisplayName[this.state];
});

JobSchema.plugin(mongooseLeanVirtuals);

JobSchema.pre('remove', async function(next) {
  const BidModel = mongoose.model('BidModel');
  const UserModel = mongoose.model('UserModel');
  try {
    const bidsToBeRemoved = await BidModel.find({ _id: { $in: this._bidsListRef } })
      .lean()
      .exec();
    if (bidsToBeRemoved && bidsToBeRemoved.length > 0) {
      let bidders = [];
      bidsToBeRemoved.forEach((bid) => {
        bidders.push(bid._bidderRef._id);
      });

      await UserModel.update(
        { _id: { $in: bidders } },
        { $pull: { _postedBidsRef: { $in: this._bidsListRef } } },
        { multi: true }
      )
        .lean()
        .exec();
    }

    await UserModel.findByIdAndUpdate(this._ownerRef, {
      $pull: { _postedJobsRef: { $in: [this._id] } },
    }).exec();

    await BidModel.remove({ _id: { $in: this._bidsListRef } }).exec();
    // delete images from cloudinary xxxx
    if (this.taskImages && this.taskImages.length > 0) {
      await Promise.all(
        this.taskImages.map(({ public_id }) => cloudinary.v2.uploader.destroy(public_id))
      );
    }
    next();
  } catch (e) {
    e.safeMsg = 'Encountered an error while deleting this job';
    next(e);
  }
  // UserModel.update(
  //   { _postedBids: { $in: this._bidsListRef } },
  //   { $pull: { _postedBids: { $in: this._bidsListRef } } },
  //   { multi: true }
  // )
  //   .then(() =>
  //     UserModel.findByIdAndUpdate(this._ownerRef, {
  //       $pull: { _postedJobsRef: { $in: this._id } },
  //     })
  //   )
  //   .then(() => BidModel.remove({ _id: { $in: this._bidsListRef } }))
  //   .then(() => next())
  //   .catch((e) => {
  //     console.log(e);
  //     throw new Error('issue deleting job');
  //   });
});

mongoose.model('JobModel', JobSchema);
